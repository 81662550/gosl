<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">
<title>Gosl &ndash; package num</title>
<link type="text/css" rel="stylesheet" href="static/style.css">
<script type="text/javascript" src="static/godocs.js"></script>
<style type="text/css"></style>
</head>
<body>
<div id="page" class=\wide">
<div class="container">
<h1>Gosl &ndash; <b>num</b> &ndash; Fundamental Numerical methods</h1>
use 'godoc cmd/github.com/cpmech/gosl/num' for documentation on the github.com/cpmech/gosl/num command 

<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = ;
	document.CALLGRAPH = ;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/cpmech/gosl/num"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
package num implements fundamental numerical methods such as numerical derivative and quadrature,
root finding solvers (Brent&#39;s and Newton&#39;s methods), among others.
</p>

			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#CompareJac">func CompareJac(tst *testing.T, ffcn fun.Vv, Jfcn fun.Tv, x []float64, tol float64)</a></dd>
			
				
				<dd><a href="#CompareJacMpi">func CompareJacMpi(tst *testing.T, ffcn fun.Vv, Jfcn fun.Tv, x []float64, tol float64, distr bool)</a></dd>
			
				
				<dd><a href="#DerivBwd4">func DerivBwd4(x, h float64, f fun.Ss) (res float64, err error)</a></dd>
			
				
				<dd><a href="#DerivCen5">func DerivCen5(x, h float64, f fun.Ss) (res float64, err error)</a></dd>
			
				
				<dd><a href="#DerivFwd4">func DerivFwd4(x, h float64, f fun.Ss) (res float64, err error)</a></dd>
			
				
				<dd><a href="#EqCubicSolveReal">func EqCubicSolveReal(a, b, c float64) (x1, x2, x3 float64, nx int)</a></dd>
			
				
				<dd><a href="#Jacobian">func Jacobian(J *la.Triplet, ffcn fun.Vv, x, fx, w []float64) (err error)</a></dd>
			
				
				<dd><a href="#JacobianMpi">func JacobianMpi(J *la.Triplet, ffcn fun.Vv, x, fx, w []float64, distr bool) (err error)</a></dd>
			
				
				<dd><a href="#LineSearch">func LineSearch(x, fx []float64, ffcn fun.Vv, dx, x0, dφdx0 []float64, φ0 float64, max_it int, dx_is_mdx bool) (nFeval int, err error)</a></dd>
			
				
				<dd><a href="#QuadDiscreteSimps2d">func QuadDiscreteSimps2d(Lx, Ly float64, f [][]float64) (V float64)</a></dd>
			
				
				<dd><a href="#QuadDiscreteSimpsonRF">func QuadDiscreteSimpsonRF(a, b float64, n int, f fun.Ss) (res float64, err error)</a></dd>
			
				
				<dd><a href="#QuadDiscreteTrapz2d">func QuadDiscreteTrapz2d(Lx, Ly float64, f [][]float64) (V float64)</a></dd>
			
				
				<dd><a href="#QuadDiscreteTrapzRF">func QuadDiscreteTrapzRF(xa, xb float64, npts int, y fun.Ss) (A float64, err error)</a></dd>
			
				
				<dd><a href="#QuadDiscreteTrapzXF">func QuadDiscreteTrapzXF(x []float64, y fun.Ss) (A float64, err error)</a></dd>
			
				
				<dd><a href="#QuadDiscreteTrapzXY">func QuadDiscreteTrapzXY(x, y []float64) (A float64)</a></dd>
			
			
				
				<dd><a href="#Brent">type Brent</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Brent.Init">func (o *Brent) Init(ffcn fun.Ss)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Brent.Min">func (o *Brent) Min(xa, xb float64, silent bool) (res float64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Brent.Solve">func (o *Brent) Solve(xa, xb float64, silent bool) (res float64, err error)</a></dd>
				
			
				
				<dd><a href="#ElementarySimpson">type ElementarySimpson</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElementarySimpson.Init">func (o *ElementarySimpson) Init(f fun.Ss, a, b, eps float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElementarySimpson.Integrate">func (o *ElementarySimpson) Integrate() (res float64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElementarySimpson.Next">func (o *ElementarySimpson) Next() (res float64, err error)</a></dd>
				
			
				
				<dd><a href="#ElementaryTrapz">type ElementaryTrapz</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElementaryTrapz.Init">func (o *ElementaryTrapz) Init(f fun.Ss, a, b, eps float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElementaryTrapz.Integrate">func (o *ElementaryTrapz) Integrate() (res float64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElementaryTrapz.Next">func (o *ElementaryTrapz) Next() (res float64, err error)</a></dd>
				
			
				
				<dd><a href="#NlSolver">type NlSolver</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NlSolver.CheckJ">func (o *NlSolver) CheckJ(x []float64, tol float64, chkJnum, silent bool) (cnd float64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NlSolver.Free">func (o *NlSolver) Free()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NlSolver.Init">func (o *NlSolver) Init(neq int, Ffcn fun.Vv, JfcnSp fun.Tv, JfcnDn fun.Mv, useDn, numJ bool, prms map[string]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NlSolver.SetTols">func (o *NlSolver) SetTols(Atol, Rtol, Ftol, ϵ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NlSolver.Solve">func (o *NlSolver) Solve(x []float64, silent bool) (err error)</a></dd>
				
			
				
				<dd><a href="#QuadElementary">type QuadElementary</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="https://github.com/cpmech/gosl/blob/master/num/auxiliary.go">auxiliary.go</a>
			
				<a href="https://github.com/cpmech/gosl/blob/master/num/brent.go">brent.go</a>
			
				<a href="https://github.com/cpmech/gosl/blob/master/num/cubicequation.go">cubicequation.go</a>
			
				<a href="https://github.com/cpmech/gosl/blob/master/num/definitions.go">definitions.go</a>
			
				<a href="https://github.com/cpmech/gosl/blob/master/num/deriv.go">deriv.go</a>
			
				<a href="https://github.com/cpmech/gosl/blob/master/num/jacobian.go">jacobian.go</a>
			
				<a href="https://github.com/cpmech/gosl/blob/master/num/jacobian_mpi.go">jacobian_mpi.go</a>
			
				<a href="https://github.com/cpmech/gosl/blob/master/num/linesearch.go">linesearch.go</a>
			
				<a href="https://github.com/cpmech/gosl/blob/master/num/nlsolver.go">nlsolver.go</a>
			
				<a href="https://github.com/cpmech/gosl/blob/master/num/quadDiscreteSimpson.go">quadDiscreteSimpson.go</a>
			
				<a href="https://github.com/cpmech/gosl/blob/master/num/quadDiscreteTrapz.go">quadDiscreteTrapz.go</a>
			
				<a href="https://github.com/cpmech/gosl/blob/master/num/quadElementary.go">quadElementary.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
    <span id="MACHEPS">MACHEPS</span> = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Nextafter">Nextafter</a>(1, 2) - 1.0 <span class="comment">// smallest number satisfying 1 + EPS &gt; 1</span>
)</pre>
				<p>
constants
</p>

			
		
		
			
			
			<h2 id="CompareJac">func <a href="https://github.com/cpmech/gosl/blob/master/num/jacobian.go?s=1378:1461#L45">CompareJac</a></h2>
			<pre>func CompareJac(tst *<a href="/pkg/testing/">testing</a>.<a href="/pkg/testing/#T">T</a>, ffcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Vv">Vv</a>, Jfcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Tv">Tv</a>, x []<a href="/pkg/builtin/#float64">float64</a>, tol <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
CompareJac compares Jacobian matrix (e.g. for testing)
</p>

			
			

		
			
			
			<h2 id="CompareJacMpi">func <a href="https://github.com/cpmech/gosl/blob/master/num/jacobian_mpi.go?s=1950:2048#L61">CompareJacMpi</a></h2>
			<pre>func CompareJacMpi(tst *<a href="/pkg/testing/">testing</a>.<a href="/pkg/testing/#T">T</a>, ffcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Vv">Vv</a>, Jfcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Tv">Tv</a>, x []<a href="/pkg/builtin/#float64">float64</a>, tol <a href="/pkg/builtin/#float64">float64</a>, distr <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
CompareJacMpi compares Jacobian matrix (e.g. for testing)
</p>

			
			

		
			
			
			<h2 id="DerivBwd4">func <a href="https://github.com/cpmech/gosl/blob/master/num/deriv.go?s=2182:2245#L66">DerivBwd4</a></h2>
			<pre>func DerivBwd4(x, h <a href="/pkg/builtin/#float64">float64</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Ss">Ss</a>) (res <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
DerivBwd4 approximates the derivative of f w.r.t x using backward differences with 4 points.
</p>

			
			

		
			
			
			<h2 id="DerivCen5">func <a href="https://github.com/cpmech/gosl/blob/master/num/deriv.go?s=321:384#L4">DerivCen5</a></h2>
			<pre>func DerivCen5(x, h <a href="/pkg/builtin/#float64">float64</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Ss">Ss</a>) (res <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
DerivCen5 approximates the derivative of f w.r.t x using central differences with 5 points.
</p>

			
			

		
			
			
			<h2 id="DerivFwd4">func <a href="https://github.com/cpmech/gosl/blob/master/num/deriv.go?s=1249:1312#L35">DerivFwd4</a></h2>
			<pre>func DerivFwd4(x, h <a href="/pkg/builtin/#float64">float64</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Ss">Ss</a>) (res <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
DerivFwd4 approximates the derivative of f w.r.t x using forward differences with 4 points.
</p>

			
			

		
			
			
			<h2 id="EqCubicSolveReal">func <a href="https://github.com/cpmech/gosl/blob/master/num/cubicequation.go?s=574:641#L9">EqCubicSolveReal</a></h2>
			<pre>func EqCubicSolveReal(a, b, c <a href="/pkg/builtin/#float64">float64</a>) (x1, x2, x3 <a href="/pkg/builtin/#float64">float64</a>, nx <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
EqCubicSolveReal solves a cubic equation, ignoring the complex answers.
</p>
<pre>The equation is specified by:
 x³ + a x² + b x + c = 0
Notes:
 1) every cubic equation with real coefficients has at least one solution
    x among the real numbers
 2) from Numerical Recipes 2007, page 228
Output:
 x[i] -- roots
 nx   -- number of real roots: 1, 2 or 3
</pre>

			
			

		
			
			
			<h2 id="Jacobian">func <a href="https://github.com/cpmech/gosl/blob/master/num/jacobian.go?s=782:855#L19">Jacobian</a></h2>
			<pre>func Jacobian(J *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, ffcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Vv">Vv</a>, x, fx, w []<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
Jacobian computes Jacobian (sparse) matrix
</p>
<pre>    Calculates (with N=n-1):
        df0dx0, df0dx1, df0dx2, ... df0dxN
        df1dx0, df1dx1, df1dx2, ... df1dxN
             . . . . . . . . . . . . .
        dfNdx0, dfNdx1, dfNdx2, ... dfNdxN
INPUT:
    ffcn : f(x) function
    x    : station where dfdx has to be calculated
    fx   : f @ x
    w    : workspace with size == n == len(x)
RETURNS:
    J : dfdx @ x [must be pre-allocated]
</pre>

			
			

		
			
			
			<h2 id="JacobianMpi">func <a href="https://github.com/cpmech/gosl/blob/master/num/jacobian_mpi.go?s=840:928#L22">JacobianMpi</a></h2>
			<pre>func JacobianMpi(J *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, ffcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Vv">Vv</a>, x, fx, w []<a href="/pkg/builtin/#float64">float64</a>, distr <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
Jacobian computes Jacobian (sparse) matrix
</p>
<pre>    Calculates (with N=n-1):
        df0dx0, df0dx1, df0dx2, ... df0dxN
        df1dx0, df1dx1, df1dx2, ... df1dxN
             . . . . . . . . . . . . .
        dfNdx0, dfNdx1, dfNdx2, ... dfNdxN
INPUT:
    ffcn : f(x) function
    x    : station where dfdx has to be calculated
    fx   : f @ x
    w    : workspace with size == n == len(x)
RETURNS:
    J : dfdx @ x [must be pre-allocated]
</pre>

			
			

		
			
			
			<h2 id="LineSearch">func <a href="https://github.com/cpmech/gosl/blob/master/num/linesearch.go?s=1253:1389#L26">LineSearch</a></h2>
			<pre>func LineSearch(x, fx []<a href="/pkg/builtin/#float64">float64</a>, ffcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Vv">Vv</a>, dx, x0, dφdx0 []<a href="/pkg/builtin/#float64">float64</a>, φ0 <a href="/pkg/builtin/#float64">float64</a>, max_it <a href="/pkg/builtin/#int">int</a>, dx_is_mdx <a href="/pkg/builtin/#bool">bool</a>) (nFeval <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
LineSearch finds a new point x along the direction dx, from x0, where the function
has decreased sufficiently. The new function value is returned in fx
</p>
<pre>Input:
    ffcn      -- f(x) callback
    dx        -- direction vector
    x0        -- initial x
    dφdx0     -- initial dφdx0 = fx * dfdx
    φ0        -- initial φ = 0.5 * dot(fx,fx)
    max_it    -- max number of iterations
    dx_is_mdx -- whether dx is actually -dx ==&gt; IMPORTANT: dx will then be changed dx := -dx
Output:
    x      -- updated x (along dx)
    fx     -- updated f(x)
    φ0     -- updated φ = 0.5 * dot(fx,fx)
    dx     -- changed to -dx if dx_is_mdx == true
    nFeval -- number of calls to f(x)
Local constants:
    tol_gra_min -- tolerance to consider local minimum
    mul_dx_max  -- multiplier to control maximum dx
    slope_max   -- ~0 but &lt; 0
    α           -- Armijo coefficient
    ε           -- machine epsilon
</pre>

			
			

		
			
			
			<h2 id="QuadDiscreteSimps2d">func <a href="https://github.com/cpmech/gosl/blob/master/num/quadDiscreteSimpson.go?s=1413:1480#L44">QuadDiscreteSimps2d</a></h2>
			<pre>func QuadDiscreteSimps2d(Lx, Ly <a href="/pkg/builtin/#float64">float64</a>, f [][]<a href="/pkg/builtin/#float64">float64</a>) (V <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
QuadDiscreteSimps2d approximates a double integral over the x-y plane with the elevation given by
data points f[npts][npts]. Thus, the result is an estimate of the volume below the f[][] opints
and the plane ortogonal to z @ x=0. The very simple Simpson&#39;s method is used here.
</p>
<pre>Lx -- total length of plane along x
Ly -- total length of plane along y
f  -- elevations f(x,y)
</pre>

			
			

		
			
			
			<h2 id="QuadDiscreteSimpsonRF">func <a href="https://github.com/cpmech/gosl/blob/master/num/quadDiscreteSimpson.go?s=465:547#L5">QuadDiscreteSimpsonRF</a></h2>
			<pre>func QuadDiscreteSimpsonRF(a, b <a href="/pkg/builtin/#float64">float64</a>, n <a href="/pkg/builtin/#int">int</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Ss">Ss</a>) (res <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
QuadDiscreteSimpsonRF approximates the area below the discrete curve defined by [xa,xy] range and
y function. Computations are carried out with the (very simple) Simpson method from xa to xb,
with npts points
</p>

			
			

		
			
			
			<h2 id="QuadDiscreteTrapz2d">func <a href="https://github.com/cpmech/gosl/blob/master/num/quadDiscreteTrapz.go?s=2186:2253#L63">QuadDiscreteTrapz2d</a></h2>
			<pre>func QuadDiscreteTrapz2d(Lx, Ly <a href="/pkg/builtin/#float64">float64</a>, f [][]<a href="/pkg/builtin/#float64">float64</a>) (V <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
QuadDiscreteTrapz2d approximates a double integral over the x-y plane with the elevation given by
data points f[npts][npts]. Thus, the result is an estimate of the volume below the f[][] opints
and the plane ortogonal to z @ x=0. The very simple trapezoidal method is used here.
</p>
<pre>Lx -- total length of plane along x
Ly -- total length of plane along y
f  -- elevations f(x,y)
</pre>

			
			

		
			
			
			<h2 id="QuadDiscreteTrapzRF">func <a href="https://github.com/cpmech/gosl/blob/master/num/quadDiscreteTrapz.go?s=1334:1417#L35">QuadDiscreteTrapzRF</a></h2>
			<pre>func QuadDiscreteTrapzRF(xa, xb <a href="/pkg/builtin/#float64">float64</a>, npts <a href="/pkg/builtin/#int">int</a>, y <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Ss">Ss</a>) (A <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
QuadDiscreteTrapzRF approximates the area below the discrete curve defined by [xa,xy] range and y
function. Computations are carried out with the (very simple) trapezoidal rule from xa to xb,
with npts points
</p>

			
			

		
			
			
			<h2 id="QuadDiscreteTrapzXF">func <a href="https://github.com/cpmech/gosl/blob/master/num/quadDiscreteTrapz.go?s=831:901#L16">QuadDiscreteTrapzXF</a></h2>
			<pre>func QuadDiscreteTrapzXF(x []<a href="/pkg/builtin/#float64">float64</a>, y <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Ss">Ss</a>) (A <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
QuadDiscreteTrapzXF approximates the area below the discrete curve defined by x points and y
function. Computations are carried out with the (very simple) trapezoidal rule.
</p>

			
			

		
			
			
			<h2 id="QuadDiscreteTrapzXY">func <a href="https://github.com/cpmech/gosl/blob/master/num/quadDiscreteTrapz.go?s=403:455#L4">QuadDiscreteTrapzXY</a></h2>
			<pre>func QuadDiscreteTrapzXY(x, y []<a href="/pkg/builtin/#float64">float64</a>) (A <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
QuadDiscreteTrapzXY approximates the area below the discrete curve defined by x and y points.
Computations are carried out with the trapezoidal rule.
</p>

			
			

		
		
			
			
			<h2 id="Brent">type <a href="https://github.com/cpmech/gosl/blob/master/num/brent.go?s=357:675#L6">Brent</a></h2>
			<pre>type Brent struct {
    MaxIt  <a href="/pkg/builtin/#int">int</a>     <span class="comment">// max iterations</span>
    Tol    <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// tolerance</span>
    Ffcn   <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Ss">Ss</a>  <span class="comment">// y = f(x) function</span>
    NFeval <a href="/pkg/builtin/#int">int</a>     <span class="comment">// number of calls to Ffcn (function evaluations)</span>
    It     <a href="/pkg/builtin/#int">int</a>     <span class="comment">// number of iterations from last call to Solve</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Brent implements Brent&#39;s method for finding the roots of an equation
</p>


			

			

			
			
			

			

			
				
				<h3 id="Brent.Init">func (*Brent) <a href="https://github.com/cpmech/gosl/blob/master/num/brent.go?s=712:745#L17">Init</a></h3>
				<pre>func (o *<a href="#Brent">Brent</a>) Init(ffcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Ss">Ss</a>)</pre>
				<p>
Init intialises Brent structure
</p>

				
				
				
			
				
				<h3 id="Brent.Min">func (*Brent) <a href="https://github.com/cpmech/gosl/blob/master/num/brent.go?s=7181:7254#L210">Min</a></h3>
				<pre>func (o *<a href="#Brent">Brent</a>) Min(xa, xb <a href="/pkg/builtin/#float64">float64</a>, silent <a href="/pkg/builtin/#bool">bool</a>) (res <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Min finds the minimum of f(x) in [xa, xb]
</p>
<pre>Based on ZEROIN C math library: <a href="http://www.netlib.org/c/">http://www.netlib.org/c/</a>
By: Oleg Keselyov &lt;oleg@ponder.csci.unt.edu, oleg@unt.edu&gt; May 23, 1991

 G.Forsythe, M.Malcolm, C.Moler, Computer methods for mathematical
 computations. M., Mir, 1980, p.202 of the Russian edition

 The function makes use of the &#34;gold section&#34; procedure combined with
 the parabolic interpolation.
 At every step program operates three abscissae - x,v, and w.
 x - the last and the best approximation to the minimum location,
     i.e. f(x) &lt;= f(a) or/and f(x) &lt;= f(b)
     (if the function f has a local minimum in (a,b), then the both
     conditions are fulfiled after one or two steps).
 v,w are previous approximations to the minimum location. They may
 coincide with a, b, or x (although the algorithm tries to make all
 u, v, and w distinct). Points x, v, and w are used to construct
 interpolating parabola whose minimum will be treated as a new
 approximation to the minimum location if the former falls within
 [a,b] and reduces the range enveloping minimum more efficient than
 the gold section procedure.
 When f(x) has a second derivative positive at the minimum location
 (not coinciding with a or b) the procedure converges superlinearly
 at a rate order about 1.324

 The function always obtains a local minimum which coincides with
 the global one only if a function under investigation being
 unimodular. If a function being examined possesses no local minimum
 within the given range, Fminbr returns &#39;a&#39; (if f(a) &lt; f(b)), otherwise
 it returns the right range boundary value b.
</pre>

				
				
				
			
				
				<h3 id="Brent.Solve">func (*Brent) <a href="https://github.com/cpmech/gosl/blob/master/num/brent.go?s=2301:2376#L52">Solve</a></h3>
				<pre>func (o *<a href="#Brent">Brent</a>) Solve(xa, xb <a href="/pkg/builtin/#float64">float64</a>, silent <a href="/pkg/builtin/#bool">bool</a>) (res <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Solve solves y(x) = 0 for x in [xa, xb] with f(xa) * f(xb) &lt; 0
</p>
<pre>Based on ZEROIN C math library: <a href="http://www.netlib.org/c/">http://www.netlib.org/c/</a>
By: Oleg Keselyov &lt;oleg@ponder.csci.unt.edu, oleg@unt.edu&gt; May 23, 1991

 G.Forsythe, M.Malcolm, C.Moler, Computer methods for mathematical
 computations. M., Mir, 1980, p.180 of the Russian edition

 The function makes use of the bissection procedure combined with
 the linear or quadric inverse interpolation.
 At every step program operates on three abscissae - a, b, and c.
 b - the last and the best approximation to the root
 a - the last but one approximation
 c - the last but one or even earlier approximation than a that
     1) |f(b)| &lt;= |f(c)|
     2) f(b) and f(c) have opposite signs, i.e. b and c confine
        the root
 At every step Zeroin selects one of the two new approximations, the
 former being obtained by the bissection procedure and the latter
 resulting in the interpolation (if a,b, and c are all different
 the quadric interpolation is utilized, otherwise the linear one).
 If the latter (i.e. obtained by the interpolation) point is
 reasonable (i.e. lies within the current interval [b,c] not being
 too close to the boundaries) it is accepted. The bissection result
 is used in the other case. Therefore, the range of uncertainty is
 ensured to be reduced at least by the factor 1.6
</pre>

				
				
				
			
		
			
			
			<h2 id="ElementarySimpson">type <a href="https://github.com/cpmech/gosl/blob/master/num/quadElementary.go?s=2815:3022#L96">ElementarySimpson</a></h2>
			<pre>type ElementarySimpson struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Simp structure implements the Simpson&#39;s method for quadrature with refinement.
</p>


			

			

			
			
			

			

			
				
				<h3 id="ElementarySimpson.Init">func (*ElementarySimpson) <a href="https://github.com/cpmech/gosl/blob/master/num/quadElementary.go?s=3059:3120#L105">Init</a></h3>
				<pre>func (o *<a href="#ElementarySimpson">ElementarySimpson</a>) Init(f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Ss">Ss</a>, a, b, eps <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Init initialises Simp structure
</p>

				
				
				
			
				
				<h3 id="ElementarySimpson.Integrate">func (*ElementarySimpson) <a href="https://github.com/cpmech/gosl/blob/master/num/quadElementary.go?s=4219:4283#L156">Integrate</a></h3>
				<pre>func (o *<a href="#ElementarySimpson">ElementarySimpson</a>) Integrate() (res <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Integrate performs the numerical integration
</p>

				
				
				
			
				
				<h3 id="ElementarySimpson.Next">func (*ElementarySimpson) <a href="https://github.com/cpmech/gosl/blob/master/num/quadElementary.go?s=3443:3502#L116">Next</a></h3>
				<pre>func (o *<a href="#ElementarySimpson">ElementarySimpson</a>) Next() (res <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Next returns the nth stage of refinement of the extended trapezoidal rule. On the first call (n=1),
R b the routine returns the crudest estimate of a f .x/dx. Subsequent calls set n=2,3,... and
improve the accuracy by adding 2 n-2 additional interior points.
</p>

				
				
				
			
		
			
			
			<h2 id="ElementaryTrapz">type <a href="https://github.com/cpmech/gosl/blob/master/num/quadElementary.go?s=934:1139#L16">ElementaryTrapz</a></h2>
			<pre>type ElementaryTrapz struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Trap structure is used for the trapezoidal integration rule with refinement.
</p>


			

			

			
			
			

			

			
				
				<h3 id="ElementaryTrapz.Init">func (*ElementaryTrapz) <a href="https://github.com/cpmech/gosl/blob/master/num/quadElementary.go?s=1176:1235#L25">Init</a></h3>
				<pre>func (o *<a href="#ElementaryTrapz">ElementaryTrapz</a>) Init(f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Ss">Ss</a>, a, b, eps <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Init initialises Trap structure
</p>

				
				
				
			
				
				<h3 id="ElementaryTrapz.Integrate">func (*ElementaryTrapz) <a href="https://github.com/cpmech/gosl/blob/master/num/quadElementary.go?s=2344:2406#L77">Integrate</a></h3>
				<pre>func (o *<a href="#ElementaryTrapz">ElementaryTrapz</a>) Integrate() (res <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Integrate performs the numerical integration
</p>

				
				
				
			
				
				<h3 id="ElementaryTrapz.Next">func (*ElementaryTrapz) <a href="https://github.com/cpmech/gosl/blob/master/num/quadElementary.go?s=1558:1615#L36">Next</a></h3>
				<pre>func (o *<a href="#ElementaryTrapz">ElementaryTrapz</a>) Next() (res <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Next returns the nth stage of refinement of the extended trapezoidal rule. On the first call (n=1),
R b the routine returns the crudest estimate of a f .x/dx. Subsequent calls set n=2,3,... and
improve the accuracy by adding 2 n-2 additional interior points.
</p>

				
				
				
			
		
			
			
			<h2 id="NlSolver">type <a href="https://github.com/cpmech/gosl/blob/master/num/nlsolver.go?s=314:1849#L6">NlSolver</a></h2>
			<pre>type NlSolver struct {
    <span class="comment">// constants</span>
    CteJac  <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// constant Jacobian (Modified Newton&#39;s method)</span>
    Lsearch <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// use linear search</span>
    LsMaxIt <a href="/pkg/builtin/#int">int</a>  <span class="comment">// linear solver maximum iterations</span>
    MaxIt   <a href="/pkg/builtin/#int">int</a>  <span class="comment">// Newton&#39;s method maximum iterations</span>
    ChkConv <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// check convergence</span>

    <span class="comment">// callbacks</span>
    Ffcn   <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Vv">Vv</a> <span class="comment">// f(x) function f:vector, x:vector</span>
    JfcnSp <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Tv">Tv</a> <span class="comment">// J(x)=dfdx Jacobian for sparse solver</span>
    JfcnDn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Mv">Mv</a> <span class="comment">// J(x)=dfdx Jacobian for dense solver</span>

    <span class="comment">// output callback</span>
    Out func(x []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#error">error</a> <span class="comment">// output callback function</span>

    <span class="comment">// data for Umfpack (sparse)</span>
    Jtri <a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a> <span class="comment">// triplet</span>

    <span class="comment">// data for dense solver (matrix inversion)</span>
    J  [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// dense Jacobian matrix</span>
    Ji [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// inverse of Jacobian matrix</span>

    <span class="comment">// stat data</span>
    It     <a href="/pkg/builtin/#int">int</a> <span class="comment">// number of iterations from the last call to Solve</span>
    NFeval <a href="/pkg/builtin/#int">int</a> <span class="comment">// number of calls to Ffcn (function evaluations)</span>
    NJeval <a href="/pkg/builtin/#int">int</a> <span class="comment">// number of calls to Jfcn (Jacobian evaluations)</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			
			
			

			

			
				
				<h3 id="NlSolver.CheckJ">func (*NlSolver) <a href="https://github.com/cpmech/gosl/blob/master/num/nlsolver.go?s=7687:7785#L321">CheckJ</a></h3>
				<pre>func (o *<a href="#NlSolver">NlSolver</a>) CheckJ(x []<a href="/pkg/builtin/#float64">float64</a>, tol <a href="/pkg/builtin/#float64">float64</a>, chkJnum, silent <a href="/pkg/builtin/#bool">bool</a>) (cnd <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
CheckJ check Jacobian matrix
</p>
<pre>Ouptut: cnd -- condition number (with Frobenius norm)
</pre>

				
				
				
			
				
				<h3 id="NlSolver.Free">func (*NlSolver) <a href="https://github.com/cpmech/gosl/blob/master/num/nlsolver.go?s=3423:3448#L124">Free</a></h3>
				<pre>func (o *<a href="#NlSolver">NlSolver</a>) Free()</pre>
				<p>
Free frees memory
</p>

				
				
				
			
				
				<h3 id="NlSolver.Init">func (*NlSolver) <a href="https://github.com/cpmech/gosl/blob/master/num/nlsolver.go?s=2108:2226#L60">Init</a></h3>
				<pre>func (o *<a href="#NlSolver">NlSolver</a>) Init(neq <a href="/pkg/builtin/#int">int</a>, Ffcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Vv">Vv</a>, JfcnSp <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Tv">Tv</a>, JfcnDn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Mv">Mv</a>, useDn, numJ <a href="/pkg/builtin/#bool">bool</a>, prms map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Init initialises solver
</p>
<pre>Input:
 useSp -- Use sparse solver with JfcnSp
 useDn -- Use dense solver (matrix inversion) with JfcnDn
 numJ  -- Use numeric Jacobian (sparse version only)
 prms  -- atol, rtol, ftol, lSearch, lsMaxIt, maxIt
</pre>

				
				
				
			
				
				<h3 id="NlSolver.SetTols">func (*NlSolver) <a href="https://github.com/cpmech/gosl/blob/master/num/nlsolver.go?s=3513:3569#L131">SetTols</a></h3>
				<pre>func (o *<a href="#NlSolver">NlSolver</a>) SetTols(Atol, Rtol, Ftol, ϵ <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
SetTols set tolerances
</p>

				
				
				
			
				
				<h3 id="NlSolver.Solve">func (*NlSolver) <a href="https://github.com/cpmech/gosl/blob/master/num/nlsolver.go?s=3720:3782#L137">Solve</a></h3>
				<pre>func (o *<a href="#NlSolver">NlSolver</a>) Solve(x []<a href="/pkg/builtin/#float64">float64</a>, silent <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Solve solves non-linear problem f(x) == 0
</p>

				
				
				
			
		
			
			
			<h2 id="QuadElementary">type <a href="https://github.com/cpmech/gosl/blob/master/num/quadElementary.go?s=581:852#L10">QuadElementary</a></h2>
			<pre>type QuadElementary interface {
    Init(f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Ss">Ss</a>, a, b, eps <a href="/pkg/builtin/#float64">float64</a>) <span class="comment">// The constructor takes as inputs f, the function or functor to be integrated between limits a and b, also input.</span>
    Integrate() (<a href="/pkg/builtin/#float64">float64</a>, <a href="/pkg/builtin/#error">error</a>)      <span class="comment">// Returns the integral for the specified input data</span>
}</pre>
			<p>
QuadElementary defines the interface for elementary quadrature algorithms with refinement.
</p>


			

			

			
			
			

			

			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	


	<div class="pkg-dir">
		<table>
			<tr>
				<th class="pkg-name">Name</th>
				<th class="pkg-synopsis">Synopsis</th>
			</tr>

			
			<tr>
				<td></td>
			</tr>
			

			
				
					<tr>
						<td class="pkg-name" style="padding-left: 0px;">
							<a href="https://github.com/cpmech/gosl/tree/master/num/data">data</a>
						</td>
						<td class="pkg-synopsis">
							
						</td>
					</tr>
				
			
		</table>
	</div>


	


<div id="footer">
<br /><br />
<hr>
<pre class="copyright">
Copyright (c) 2016, The Gosl Authors. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of Gosl nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

</pre><!-- copyright -->
</div><!-- footer -->

</div><!-- container -->
</div><!-- page -->
</body>
</html>
